// ------------------------------------------------------------------------------------------
//  Copyright (c) Natsuneko. All rights reserved.
//  Licensed under the MIT License. See LICENSE in the project root for license information.
// ------------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

using NatsunekoLaboratory.ErrorTracker.Serializer;

using UnityEditor;

using UnityEngine;

namespace NatsunekoLaboratory.ErrorTracker
{
    public static class ErrorTracker
    {
        private static readonly List<string> Messages = new List<string>();
        private static string ApplicationRoot => Path.GetFullPath(Path.Combine(Application.dataPath, ".."));

        [InitializeOnLoadMethod]
        private static void InitializeOnLoad()
        {
            Application.logMessageReceived -= OnLogMessageReceived;
            Application.logMessageReceived += OnLogMessageReceived;
        }

        [MenuItem("Help/Natsuneko Laboratory/Generate Error Report")]
        private static void OnClickGenerateErrorReport()
        {
            var dependencies = Concat(
                LoadPackageDependencies(),
                LoadEmbeddedDependencies(),
                LoadVRChatDependencies(),
                LoadProjectImports()
            );

            var sb = new StringBuilder();
            sb.AppendLine("# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.");
            sb.AppendLine("# NatsunekoLaboratory.ErrorTracker V1");
            sb.AppendLine();
            sb.AppendLine("Unity Player Version:");
            sb.AppendLine($"    {Application.unityVersion}");
            sb.AppendLine();
            sb.AppendLine("Platform:");
            sb.AppendLine($"    {Environment.OSVersion}");
            sb.AppendLine();
            sb.AppendLine("Trace:");

            foreach (var message in Messages)
                sb.AppendLine($"    {message}");

            sb.AppendLine();
            sb.AppendLine("Dependencies:");

            foreach (var dependency in dependencies)
                sb.AppendLine($"    {dependency.Key}@{dependency.Value}");

            sb.AppendLine();

            GUIUtility.systemCopyBuffer = sb.ToString();
            EditorUtility.DisplayDialog("NatsunekoLaboratory Error Tracker", "Copy Error Tracker Logs to Clipboard!", "OK");

            Messages.Clear();
        }

        /// <summary>
        ///     read dependencies from Packages/manifest.json#dependencies
        /// </summary>
        /// <returns></returns>
        private static Dictionary<string, string> LoadPackageDependencies()
        {
            var versions = new Dictionary<string, string>();
            var manifest = Path.Combine(ApplicationRoot, "Packages", "manifest.json");
            if (File.Exists(manifest))
            {
                var json = File.ReadAllText(manifest);
                var obj = Json.Parse(json);
                var dependencies = obj["dependencies"];

                foreach (var dependency in dependencies)
                    versions.Add(dependency.Key, dependency.Value);
            }

            return versions;
        }

        /// <summary>
        ///     read dependencies from Packages directory
        /// </summary>
        /// <returns></returns>
        private static Dictionary<string, string> LoadEmbeddedDependencies()
        {
            var versions = new Dictionary<string, string>();
            var packages = Path.Combine(ApplicationRoot, "Packages");
            if (Directory.Exists(packages))
            {
                var dirs = Directory.GetDirectories(packages);
                foreach (var dir in dirs)
                {
                    var package = Path.Combine(dir, "package.json");
                    if (File.Exists(package))
                    {
                        var json = File.ReadAllText(package);
                        var obj = Json.Parse(json);

                        versions.Add(obj["name"], obj["version"]);
                    }
                }
            }

            return versions;
        }

        /// <summary>
        ///     read dependencies from Packages/vpm-manifest.json#dependencies
        /// </summary>
        /// <returns></returns>
        // ReSharper disable once InconsistentNaming
        private static Dictionary<string, string> LoadVRChatDependencies()
        {
            var versions = new Dictionary<string, string>();
            var manifest = Path.Combine(ApplicationRoot, "Packages", "vpm-manifest.json");
            if (File.Exists(manifest))
            {
                var json = File.ReadAllText(manifest);
                var obj = Json.Parse(json);
                var dependencies = obj["dependencies"];

                foreach (var dependency in dependencies)
                    versions.Add(dependency.Key, dependency.Value["version"]);
            }

            return versions;
        }

        /// <summary>
        ///     read assembly definition files from Assets
        /// </summary>
        /// <returns></returns>
        private static Dictionary<string, string> LoadProjectImports()
        {
            var versions = new Dictionary<string, string>();
            var assets = Path.Combine(ApplicationRoot, "Assets");

            // assembly definition files
            var definitions = Directory.GetFiles(assets, "*.asmdef", SearchOption.AllDirectories);

            foreach (var definition in definitions)
                try
                {
                    var json = File.ReadAllText(definition);
                    var obj = Json.Parse(json);
                    versions.Add(obj["name"], "unitypackage");
                }
                catch
                {
                    // ignored
                }

            // packages
            var packages = Directory.GetFiles(assets, "package.json", SearchOption.AllDirectories);

            foreach (var package in packages)
                try
                {
                    var json = File.ReadAllText(package);
                    var obj = Json.Parse(json);
                    versions.Add(obj["name"], obj["version"]);
                }
                catch
                {
                    // ignored
                }


            return versions;
        }

        private static Dictionary<string, string> Concat(params Dictionary<string, string>[] dictionaries)
        {
            var dictionary = new Dictionary<string, string>();

            foreach (var dict in dictionaries)
            foreach (var item in dict.Where(item => !dictionary.ContainsKey(item.Key)))
                dictionary.Add(item.Key, item.Value);

            return dictionary;
        }

        private static void OnLogMessageReceived(string condition, string stacktrace, LogType type)
        {
            var stacks = new List<string>();
            foreach (var msg in stacktrace.Split('\n').Where(w => !string.IsNullOrWhiteSpace(w)))
                stacks.Add($"        at {msg}");

            switch (type)
            {
                case LogType.Error:
                    Messages.Insert(0, $"[ERROR] {condition}{Environment.NewLine}{string.Join(Environment.NewLine, stacks)}");
                    break;

                case LogType.Assert:
                    // black-hole
                    break;

                case LogType.Warning:
                    Messages.Insert(0, $"[WARN] {condition}{Environment.NewLine}{string.Join(Environment.NewLine, stacks)}");
                    break;

                case LogType.Log:
                    // black-hole
                    break;

                case LogType.Exception:
                    Messages.Insert(0, $"[FATAL] {condition}{Environment.NewLine}{string.Join(Environment.NewLine, stacks)}");
                    break;

                default:
                    throw new ArgumentOutOfRangeException(nameof(type), type, null);
            }
        }
    }
}