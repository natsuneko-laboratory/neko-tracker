// ------------------------------------------------------------------------------------------
//  Copyright (c) Natsuneko. All rights reserved.
//  Licensed under the MIT License. See LICENSE in the project root for license information.
// ------------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

using NatsunekoLaboratory.TraceMate.Redactor;
using NatsunekoLaboratory.TraceMate.Serializer;

using UnityEditor;

using UnityEngine;

namespace NatsunekoLaboratory.TraceMate
{
    public static class TraceMateReporter
    {
        private static readonly FixedSizeQueue Messages = new FixedSizeQueue(50);
        private const string TraceMateSessionKey = "NatsunekoLaboratory.TraceMate.Logs";
        private static string ApplicationRoot => Path.GetFullPath(Path.Combine(Application.dataPath, ".."));

        [InitializeOnLoadMethod]
        private static void InitializeOnLoad()
        {
            Application.logMessageReceived -= OnLogMessageReceived;
            Application.logMessageReceived += OnLogMessageReceived;

            var previousSessionData = SessionState.GetString(TraceMateSessionKey, "");
            if (string.IsNullOrWhiteSpace(previousSessionData))
                return;

            var messages = JsonUtility.FromJson<List<string>>(previousSessionData);
            foreach ( var message in messages )
                Messages.Enqueue(message);
        }

        [MenuItem("Help/Natsuneko Laboratory/Generate TraceMate Report")]
        private static void OnClickGenerateTraceMateReport()
        {
            GenerateTraceMateReport();
        }

        [MenuItem("Help/Natsuneko Laboratory/Generate TraceMate Report without Masking")]
        private static void OnClickGenerateTraceMateReportWithoutMasking()
        {
            GenerateTraceMateReport(false);
        }

        private static void GenerateTraceMateReport(bool isMasking = true)
        {
            var dependencies = Concat(
                LoadPackageDependencies(),
                LoadEmbeddedDependencies(),
                LoadVRChatDependencies(),
                LoadProjectImports()
            );

            var sb = new StringBuilder();
            sb.AppendLine("# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.");
            sb.AppendLine($"# {typeof(TraceMateReporter).FullName} V1");
            sb.AppendLine();
            sb.AppendLine("Unity Player Version:");
            sb.AppendLine($"    {Application.unityVersion}");
            sb.AppendLine();
            sb.AppendLine("Platform:");
            sb.AppendLine($"    {Environment.OSVersion}");
            sb.AppendLine();
            sb.AppendLine("Trace:");

            foreach (var message in Messages.AsList())
                sb.AppendLine($"    {message}");

            sb.AppendLine();
            sb.AppendLine("Dependencies:");

            foreach (var dependency in dependencies)
                sb.AppendLine($"    {dependency.Key}@{dependency.Value}");

            sb.AppendLine();

            GUIUtility.systemCopyBuffer = isMasking ? TraceMateRedactor.Redact(sb.ToString()) : sb.ToString();
            EditorUtility.DisplayDialog("NatsunekoLaboratory TraceMate", "TraceMate Logs to Clipboard!", "OK");

        }

        /// <summary>
        ///     read dependencies from Packages/manifest.json#dependencies
        /// </summary>
        /// <returns></returns>
        private static Dictionary<string, string> LoadPackageDependencies()
        {
            var versions = new Dictionary<string, string>();
            var manifest = Path.Combine(ApplicationRoot, "Packages", "manifest.json");
            if (File.Exists(manifest))
            {
                var json = File.ReadAllText(manifest);
                var obj = Json.Parse(json);
                var dependencies = obj["dependencies"];

                foreach (var dependency in dependencies)
                    versions.Add(dependency.Key, dependency.Value);
            }

            return versions;
        }

        /// <summary>
        ///     read dependencies from Packages directory
        /// </summary>
        /// <returns></returns>
        private static Dictionary<string, string> LoadEmbeddedDependencies()
        {
            var versions = new Dictionary<string, string>();
            var packages = Path.Combine(ApplicationRoot, "Packages");
            if (Directory.Exists(packages))
            {
                var dirs = Directory.GetDirectories(packages);
                foreach (var dir in dirs)
                {
                    var package = Path.Combine(dir, "package.json");
                    if (File.Exists(package))
                    {
                        var json = File.ReadAllText(package);
                        var obj = Json.Parse(json);

                        versions.Add(obj["name"], obj["version"]);
                    }
                }
            }

            return versions;
        }

        /// <summary>
        ///     read dependencies from Packages/vpm-manifest.json#dependencies
        /// </summary>
        /// <returns></returns>
        // ReSharper disable once InconsistentNaming
        private static Dictionary<string, string> LoadVRChatDependencies()
        {
            var versions = new Dictionary<string, string>();
            var manifest = Path.Combine(ApplicationRoot, "Packages", "vpm-manifest.json");
            if (File.Exists(manifest))
            {
                var json = File.ReadAllText(manifest);
                var obj = Json.Parse(json);
                var dependencies = obj["dependencies"];

                foreach (var dependency in dependencies)
                    versions.Add(dependency.Key, dependency.Value["version"]);
            }

            return versions;
        }

        /// <summary>
        ///     read assembly definition files from Assets
        /// </summary>
        /// <returns></returns>
        private static Dictionary<string, string> LoadProjectImports()
        {
            var versions = new Dictionary<string, string>();
            var assets = Path.Combine(ApplicationRoot, "Assets");

            // assembly definition files
            var definitions = Directory.GetFiles(assets, "*.asmdef", SearchOption.AllDirectories);

            foreach (var definition in definitions)
                try
                {
                    var json = File.ReadAllText(definition);
                    var obj = Json.Parse(json);
                    versions.Add(obj["name"], "unitypackage");
                }
                catch
                {
                    // ignored
                }

            // packages
            var packages = Directory.GetFiles(assets, "package.json", SearchOption.AllDirectories);

            foreach (var package in packages)
                try
                {
                    var json = File.ReadAllText(package);
                    var obj = Json.Parse(json);
                    versions.Add(obj["name"], obj["version"]);
                }
                catch
                {
                    // ignored
                }


            return versions;
        }

        private static Dictionary<string, string> Concat(params Dictionary<string, string>[] dictionaries)
        {
            var dictionary = new Dictionary<string, string>();

            foreach (var dict in dictionaries)
            foreach (var item in dict.Where(item => !dictionary.ContainsKey(item.Key)))
                dictionary.Add(item.Key, item.Value);

            return dictionary;
        }

        private static void OnLogMessageReceived(string condition, string stacktrace, LogType type)
        {
            var stacks = new List<string>();

            foreach (var (msg, i) in condition.Split('\n').Where(w => !string.IsNullOrWhiteSpace(w)).Select((w, i) => (w, i)))
            {
                if (i == 0)
                {
                    stacks.Add(msg);
                    continue;
                }

                var s = msg.Trim();
                stacks.Add(s.StartsWith("at ") ? $"        {s}" : $"         at {s}");
            }

            foreach (var msg in stacktrace.Split('\n').Where(w => !string.IsNullOrWhiteSpace(w)))
                stacks.Add($"        at {msg}");

            switch (type)
            {
                case LogType.Error:
                    Messages.Enqueue($"[ERROR] {string.Join(Environment.NewLine, stacks)}");
                    break;

                case LogType.Assert:
                    // black-hole
                    break;

                case LogType.Warning:
                    Messages.Enqueue($"[WARN] {string.Join(Environment.NewLine, stacks)}");
                    break;

                case LogType.Log:
                    // black-hole
                    break;

                case LogType.Exception:
                    Messages.Enqueue($"[FATAL] {string.Join(Environment.NewLine, stacks)}");
                    break;

                default:
                    throw new ArgumentOutOfRangeException(nameof(type), type, null);
            }
        }
    }
}